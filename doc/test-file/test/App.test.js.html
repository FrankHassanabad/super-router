<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/App.test.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/autoric/super-router" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Response.js~Response.html">Response</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Router.js~Router.html">Router</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/App.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;
const chai              = require(&apos;chai&apos;);
const sinon             = require(&apos;sinon&apos;);
const sinonChai         = require(&apos;sinon-chai&apos;);
const sinonStubPromises = require(&apos;sinon-promises&apos;);
const chaiAsPromised    = require(&apos;chai-as-promised&apos;);
const proxyquire        = require(&apos;proxyquire&apos;);
const Q                 = require(&apos;q&apos;);

sinonStubPromises(sinon);
chai.use(chaiAsPromised);
chai.use(sinonChai);

const expect  = chai.expect;
const sandbox = sinon.sandbox.create();

const Request  = require(&apos;../lib/Request&apos;);
const Response = require(&apos;../lib/Response&apos;);
const Route    = require(&apos;../lib/Route&apos;);

let App;
let app;

describe(&apos;App&apos;, () =&gt; {

  beforeEach(() =&gt; {
    App = require(&apos;../lib/App&apos;);
    app = new App();
  });

  describe(&apos;constructor&apos;, () =&gt; {

  });

  describe(&apos;use&apos;, () =&gt; {
    let mockRoute;

    beforeEach(() =&gt; {
      mockRoute = sinon.spy();
      App       = proxyquire(&apos;../lib/App&apos;, {
        &apos;./Route&apos; : mockRoute
      });
      app       = new App();
    });


    it(&apos;should run the input through the Route constructor if it is not a Route instance&apos;, () =&gt; {
      const opts = {};
      app.then(opts);
      expect(mockRoute).to.have.been.calledOnce;
      expect(mockRoute).to.have.been.calledWithNew;
      expect(mockRoute).to.have.been.calledWith(opts);
    });

    it(&apos;should not run the input through the Route constructor if it is a Route instance&apos;, () =&gt; {
      const route = new mockRoute({ handler : sinon.spy() });
      mockRoute.reset();

      app.then(route);
      expect(mockRoute).to.not.have.been.called;
    });

    it(&apos;should accept a function input and use it as a route handler&apos;, () =&gt; {
      const opts = sinon.spy();
      app.then(opts);
      expect(mockRoute).to.have.been.calledOnce;
      expect(mockRoute).to.have.been.calledWithNew;
      expect(mockRoute).to.have.been.calledWith({
        handler : opts
      });
    });
  });

  describe(&apos;useError&apos;, () =&gt; {
    let mockRoute;

    beforeEach(() =&gt; {
      mockRoute = sinon.spy();
      App       = proxyquire(&apos;../lib/App&apos;, {
        &apos;./Route&apos; : mockRoute
      });
      app       = new App();
    });


    it(&apos;should run the input through the Route constructor if it is not a Route instance&apos;, () =&gt; {
      const opts = {};
      app.catch(opts);
      expect(mockRoute).to.have.been.calledOnce;
      expect(mockRoute).to.have.been.calledWithNew;
      expect(mockRoute).to.have.been.calledWith(opts);
    });

    it(&apos;should not run the input through the Route constructor if it is a Route instance&apos;, () =&gt; {
      const route = new mockRoute({ handler : sinon.spy() });
      mockRoute.reset();

      app.catch(route);
      expect(mockRoute).to.not.have.been.called;
    });

    it(&apos;should accept a function input and use it as a route handler&apos;, () =&gt; {
      const opts = sinon.spy();
      app.catch(opts);
      expect(mockRoute).to.have.been.calledOnce;
      expect(mockRoute).to.have.been.calledWithNew;
      expect(mockRoute).to.have.been.calledWith({
        handler : opts
      });
    });
  });

  describe(&apos;processRequest&apos;, () =&gt; {
    let request;
    let middleware1;
    let middleware2;
    let middleware3;
    let middleware4;
    let errMiddleware1;
    let errMiddleware2;
    let errMiddleware3;
    let errMiddleware4;

    beforeEach(() =&gt; {
      request = new Request({
        headers : {},
        path    : &apos;/a&apos;,
        method  : &apos;get&apos;
      });

      middleware1 = sinon.createStubInstance(Route);
      middleware2 = sinon.createStubInstance(Route);
      middleware3 = new Route({
        handler : sinon.spy(function (opts) {
          opts.response.end();
        })
      });
      middleware4 = sinon.createStubInstance(Route);

      errMiddleware1 = new Route({
        handler : sinon.spy()
      });
      sandbox.stub(errMiddleware1, &apos;execute&apos;);
      errMiddleware2 = new Route({
        handler : sinon.spy()
      });
      sandbox.stub(errMiddleware2, &apos;execute&apos;);
      errMiddleware3 = new Route({
        handler : sinon.spy(function (opts) {
          opts.response.end();
          throw new Error(&apos;Failure&apos;);
        })
      });
      errMiddleware4 = new Route({
        handler : sinon.spy()
      });
      sandbox.stub(errMiddleware4, &apos;execute&apos;);

      app.then(middleware1);
      app.then(middleware2);

      app.catch(errMiddleware1);
      app.catch(errMiddleware2);
    });

    it(&apos;should create a new Request object if the input is not a Request object&apos;, () =&gt; {
      const mockRequest = sinon.stub();
      const opts        = {};
      App               = proxyquire(&apos;../lib/App&apos;, {
        &apos;./Request&apos; : mockRequest
      });
      app = new App();

      app.processRequest(opts);
      expect(mockRequest).to.have.been.calledOnce;
      expect(mockRequest).to.have.been.calledWith(opts);
    });

    it(&apos;should return a promise&apos;, () =&gt; {
      expect(Q.isPromise(app.processRequest(request))).to.be.true;
    });

    it(&apos;should create a new response object&apos;, () =&gt; {
      const Response     = sinon.stub();
      const mockResponse = {
        pipe : sinon.spy()
      };
      Response.returns(mockResponse);
      App                = proxyquire(&apos;../lib/App&apos;, {
        &apos;./Response&apos; : Response
      });
      app                = new App();

      app.then(middleware1);
      app.then(middleware2);

      return app.processRequest(request).then(() =&gt; {
        expect(Response).to.have.calledOnce;
      });
    });

    it(&apos;should execute each route with request in the order declared&apos;, () =&gt; {
      return app.processRequest(request).then(() =&gt; {
        expect(middleware1.execute).to.have.been.calledOnce;
        expect(middleware1.execute.firstCall.args[0].request).to.equal(request);
        expect(middleware2.execute).to.have.been.calledOnce;
        expect(middleware2.execute.firstCall.args[0].request).to.equal(request);

        expect(middleware1.execute).to.have.been.calledBefore(middleware2.execute);
      });
    });

    it(&apos;should not execute the second middleware before the first one completes&apos;, () =&gt; {
      middleware1.execute.returnsPromise();
      middleware1.execute.rejects(new Error());

      return app.processRequest(request).catch(() =&gt; {
        expect(middleware1.execute).to.have.been.called;
        expect(middleware2.execute).to.not.have.been.called;
      });
    });

    it(&apos;should not execute error middleware if all middleware resolves&apos;, () =&gt; {
      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.execute).to.not.have.been.called;
        expect(errMiddleware2.execute).to.not.have.been.called;
      });
    });

    it(&apos;should resolve with the created response object&apos;, () =&gt; {
      return app.processRequest(request).then((response) =&gt; {
        expect(response).to.be.instanceof(Response);
      });
    });

    it(&apos;should bail from the middleware stack if response.end is true&apos;, () =&gt; {
      app.then(middleware3);
      app.then(middleware4);
      return app.processRequest(request).then(() =&gt; {
        expect(middleware3.handler).to.have.been.calledOnce;
        expect(middleware4.execute).to.not.have.been.calledOnce;
      });
    });

    it(&apos;should bail from the error stack if response.end is true&apos;, () =&gt; {
      const err = new Error(&apos;uhoh&apos;);
      const err2 = new Error(&apos;ohno&apos;);
      middleware1.execute.throws(err);
      errMiddleware1.execute.throws(err2);
      errMiddleware2.execute.throws(err2);
      app.catch(errMiddleware3);
      app.catch(errMiddleware4);

      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware3.handler).to.have.been.calledOnce;
        expect(errMiddleware4.execute).to.not.have.been.calledOnce;
      });
    });

    it(&apos;should bail to the error stack if a middleware throws an error&apos;, () =&gt; {
      const err = new Error(&apos;uhoh&apos;);
      middleware1.execute.throws(err);

      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware1.execute.firstCall.args[0].error).to.equal(err);
        expect(errMiddleware2.execute).to.not.have.been.calledOnce;
      });
    });

    it(&apos;should propagate down the error stack if a previous error middleware throws an error&apos;, () =&gt; {
      const err1 = new Error(&apos;uhoh&apos;);
      const err2 = new Error(&apos;ohno&apos;);
      middleware1.execute.throws(err1);
      errMiddleware1.execute.throws(err2);

      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware1.execute.firstCall.args[0].error).to.equal(err1);
        expect(errMiddleware2.execute).to.have.been.calledOnce;
        expect(errMiddleware2.execute.firstCall.args[0].error).to.equal(err2);
      });
    });

    it(&apos;should bail to the error stack if a middleware rejects with an error&apos;, () =&gt; {
      const err = new Error(&apos;uhoh&apos;);
      middleware1.execute.returnsPromise();
      middleware1.execute.rejects(err);

      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware1.execute.firstCall.args[0].error).to.equal(err);
        expect(errMiddleware2.execute).to.not.have.been.calledOnce;
      });
    });

    it(&apos;should propagate down the error stack if a previous error middleware rejects with an error&apos;, () =&gt; {
      const err1 = new Error(&apos;uhoh&apos;);
      const err2 = new Error(&apos;ohno&apos;);
      middleware1.execute.throws(err1);
      errMiddleware1.execute.returnsPromise();
      errMiddleware1.execute.rejects(err2);

      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware1.execute.firstCall.args[0].error).to.equal(err1);
        expect(errMiddleware2.execute).to.have.been.calledOnce;
        expect(errMiddleware2.execute.firstCall.args[0].error).to.equal(err2);
      });
    });

    it(&apos;should not allow a path specific error middleware to swallow a valid error condition&apos;, () =&gt; {
      app            = new App();

      app.then(middleware1);
      errMiddleware1 = new Route({
        path    : &apos;/a/b/c&apos;,
        method  : &apos;get&apos;,
        handler : sinon.spy()
      });
      app.catch(errMiddleware1);
      app.catch(errMiddleware2);

      const err1 = new Error(&apos;uhoh&apos;);
      middleware1.execute.throws(err1);
      return app.processRequest(request).then(() =&gt; {
        expect(errMiddleware1.handler).to.not.have.been.called;
        expect(errMiddleware2.execute).to.have.been.calledOnce;
      });
    });

    it(&apos;should reject if all error middleware throw&apos;, () =&gt; {
      const err1 = new Error(&apos;uhoh&apos;);
      const err2 = new Error(&apos;ohno&apos;);
      const err3 = new Error(&apos;nodearlord&apos;);
      middleware1.execute.throws(err1);
      errMiddleware1.execute.throws(err2);
      errMiddleware2.execute.throws(err3);

      return app.processRequest(request).catch((e) =&gt; {
        expect(e).to.equal(err3);
      });
    });
  });

  describe(&apos;processRequest with middleware specific error handlers&apos;, () =&gt; {
    let request;
    let middleware1;
    let middleware2;
    let middleware3;
    let middleware4;
    let errMiddleware1;
    let errMiddleware2;
    let genericError;

    beforeEach(() =&gt; {
      request = new Request({
        headers : {},
        path    : &apos;/a&apos;,
        method  : &apos;get&apos;
      });

      genericError = new Error(&apos;Something bad happened.&apos;);

      middleware1 = sinon.createStubInstance(Route);
      middleware2 = sinon.createStubInstance(Route);
      middleware3 = sinon.createStubInstance(Route);
      middleware4 = sinon.createStubInstance(Route);

      errMiddleware1 = new Route({
        handler : sinon.spy()
      });
      sandbox.stub(errMiddleware1, &apos;execute&apos;);
      errMiddleware2 = new Route({
        handler : sinon.spy()
      });
      sandbox.stub(errMiddleware2, &apos;execute&apos;);

      app.then(middleware1);
      app.then(middleware2);
      app.then(middleware3);
      app.catch(errMiddleware1);
      app.catch(errMiddleware2);
      app.then(middleware4);

      middleware1.execute.returnsPromise();
      errMiddleware1.execute.returnsPromise();
      errMiddleware2.execute.returnsPromise();
    });

    it(&apos;no errors&apos;, () =&gt; {
      return app.processRequest(request).then(() =&gt; {
        expect(middleware1.execute).to.have.been.calledOnce;
        expect(middleware2.execute).to.have.been.calledOnce;
        expect(middleware3.execute).to.have.been.calledOnce;
        expect(errMiddleware1.execute).to.not.have.been.called;
        expect(errMiddleware2.execute).to.not.have.been.called;
        expect(middleware4.execute).to.have.been.calledOnce;
      });
    });

    it(&apos;early error that gets back on happy path&apos;, () =&gt; {
      middleware1.execute.rejects(genericError);

      return app.processRequest(request).then(() =&gt; {
        expect(middleware1.execute).to.have.been.calledOnce;
        expect(middleware2.execute).to.not.have.been.called;
        expect(middleware3.execute).to.not.have.been.called;
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware2.execute).to.not.have.been.called;
        expect(middleware4.execute).to.have.been.calledOnce;
      });
    });

    it(&apos;early error that gets back on happy path after erroring in error chain&apos;, () =&gt; {
      middleware1.execute.rejects(genericError);
      errMiddleware1.execute.rejects(genericError);

      return app.processRequest(request).then(() =&gt; {
        expect(middleware1.execute).to.have.been.calledOnce;
        expect(middleware2.execute).to.not.have.been.called;
        expect(middleware3.execute).to.not.have.been.called;
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware2.execute).to.have.been.calledOnce;
        expect(middleware4.execute).to.have.been.calledOnce;
      });
    });

    it(&apos;should bubble up error if last error middleware throws error&apos;, () =&gt; {
      middleware1.execute.rejects(genericError);
      errMiddleware1.execute.rejects(genericError);
      errMiddleware2.execute.rejects(genericError);

      return app.processRequest(request).catch(() =&gt; {
        expect(middleware1.execute).to.have.been.calledOnce;
        expect(middleware2.execute).to.not.have.been.called;
        expect(middleware3.execute).to.not.have.been.called;
        expect(errMiddleware1.execute).to.have.been.calledOnce;
        expect(errMiddleware2.execute).to.have.been.calledOnce;
        expect(middleware4.execute).to.not.have.been.calledOnce;
      });
    });

  });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
