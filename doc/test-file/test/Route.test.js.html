<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/Route.test.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/autoric/super-router" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Response.js~Response.html">Response</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Router.js~Router.html">Router</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/Route.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;
const chai              = require(&apos;chai&apos;);
const sinon             = require(&apos;sinon&apos;);
const sinonChai         = require(&apos;sinon-chai&apos;);
const sinonStubPromises = require(&apos;sinon-promises&apos;);
const chaiAsPromised    = require(&apos;chai-as-promised&apos;);
const _                 = require(&apos;lodash&apos;);
const Q                 = require(&apos;q&apos;);

sinonStubPromises(sinon);
chai.use(chaiAsPromised);
chai.use(sinonChai);

const expect = chai.expect;

const Route    = require(&apos;../lib/Route&apos;);
const Request  = require(&apos;../lib/Request&apos;);
const Response = require(&apos;../lib/Response&apos;);

describe(&apos;A Route&apos;, () =&gt; {
  let opts;
  let route;
  let handler;

  beforeEach(() =&gt; {
    handler = sinon.stub();
    opts    = { path : &apos;/&apos;, method : &apos;GET&apos;, handler : handler };
    route   = new Route(opts);
  });

  describe(&apos;constructor&apos;, () =&gt; {
    const OPTIONS_ERROR = &apos;options must be an object.&apos;;
    const PATH_ERROR    = &apos;path must be a string.&apos;;
    const METHOD_ERROR  = &apos;method must be a valid method string.&apos;;
    const HANDLER_ERROR = &apos;handler must be a function.&apos;;

    it(&apos;should throw if options is undefined&apos;, () =&gt; {
      expect(() =&gt; {
        new Route();
      }).to.throw(OPTIONS_ERROR);
    });

    it(&apos;should throw if options is not an object&apos;, () =&gt; {
      expect(() =&gt; {
        new Route(&apos;asdf&apos;);
      }).to.throw(OPTIONS_ERROR);
    });

    it(&apos;should throw if handler is not defined;&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({});
      }).to.throw(HANDLER_ERROR);
    });

    it(&apos;should throw if handler is not a function&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : &apos;asdf&apos; });
      }).to.throw(HANDLER_ERROR);
    });

    it(&apos;should not throw if options.path is undefined&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : sinon.spy() });
      }).to.not.throw();
    });

    it(&apos;should throw if options.path is not a string&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : sinon.spy(), path : 7 });
      }).to.throw(PATH_ERROR);
    });

    it(&apos;should not throw if options.method is undefined&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : sinon.spy() });
      }).to.not.throw();
    });

    it(&apos;should throw if options.method is not a string&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : sinon.spy(), method : 7 });
      }).to.throw(METHOD_ERROR);
    });

    it(&apos;should throw if options.method is not an allowed method value&apos;, () =&gt; {
      expect(() =&gt; {
        new Route({ handler : sinon.spy(), method : &apos;heart!&apos; });
      }).to.throw(METHOD_ERROR);
    });

  });

  describe(&apos;properties&apos;, () =&gt; {
    _.each([&apos;path&apos;, &apos;method&apos;, &apos;handler&apos;], (propertyName) =&gt; {
      it(`should set property ${propertyName} from constructor`, () =&gt; {
        expect(route[propertyName]).to.equal(opts[propertyName]);
      });

      it(`should throw on assignment to ${propertyName}`, () =&gt; {
        expect(() =&gt; {
          route[propertyName] = &apos;a&apos;;
        }).to.throw(&apos;Cannot set property&apos;);
      });
    });

    it(&apos;should normalize root path&apos;, () =&gt; {
      route = new Route({ path : &apos;/&apos;, method : &apos;get&apos;, handler : handler });
      expect(route.path).to.equal(&apos;/&apos;);
    });

    it(&apos;should normalize trailing slashes&apos;, () =&gt; {
      route = new Route({ path : &apos;/a/b/c/&apos;, method : &apos;get&apos;, handler : handler });
      expect(route.path).to.equal(&apos;/a/b/c&apos;);
    });

    it(&apos;should normalize trailing slashes&apos;, () =&gt; {
      route = new Route({ path : &apos;/a/b/c&apos;, method : &apos;get&apos;, handler : handler });
      expect(route.path).to.equal(&apos;/a/b/c&apos;);
    });

    it(&apos;should lowercase path parts that are NOT route params&apos;, () =&gt; {
      route = new Route({ path : &apos;/CaSes/:caseId/THINg&apos;, method : &apos;get&apos;, handler : handler });
      expect(route.path).to.equal(&apos;/cases/:caseId/thing&apos;);
    });

    it(&apos;should normalize method name&apos;, () =&gt; {
      route = new Route({ path : &apos;/a/b/c&apos;, method : &apos;GeT&apos;, handler : handler });
      expect(route.method).to.equal(&apos;GET&apos;);
    });

    it(&apos;should default method to ALL&apos;, () =&gt; {
      route = new Route({ path : &apos;/a/b/c&apos;, handler : handler });
      expect(route.method).to.equal(&apos;*&apos;);
    });

    it(&apos;should default path to all&apos;, () =&gt; {
      route = new Route({ handler : handler });
      expect(route.path).to.equal(&apos;*all&apos;);
    });

    it(&apos;should extend with arbitrary parameters&apos;, () =&gt; {
      route = new Route(_.extend({}, opts, { a : 1, b : &apos;AHHH&apos; }));

      expect(route.a).to.equal(1);
      expect(route.b).to.equal(&apos;AHHH&apos;);
    });

    it(&apos;should not allow arbitrary parameters to overwrite internal state&apos;, () =&gt; {
      route = new Route(_.extend({}, opts, { _path : &apos;okthen?&apos; }));

      expect(route.path).to.equal(&apos;/&apos;);
    });
  });

  describe(&apos;isMatch&apos;, () =&gt; {
    it(&apos;should throw if the input is not a request object&apos;, () =&gt; {
      expect(() =&gt; {
        route.isMatch({});
      }).to.throw(&apos;First argument: request must be a SuperRouter Request instance.&apos;);
    });

    it(&apos;should return true if a request is an exact match for the route&apos;, () =&gt; {
      const req = new Request({
        method  : &apos;get&apos;,
        path    : &apos;/&apos;,
        headers : {}
      });

      expect(route.isMatch(req)).to.be.true;
    });

    it(&apos;should return true for any method if the route is to match all methods&apos;, () =&gt; {
      route = new Route({
        method  : &apos;*&apos;,
        path    : &apos;/&apos;,
        handler : sinon.spy()
      });

      const req = new Request({
        method  : &apos;get&apos;,
        path    : &apos;/&apos;,
        headers : {}
      });

      expect(route.isMatch(req)).to.be.true;
    });

    it(&apos;should return true for any method if the route is to match all paths&apos;, () =&gt; {
      route = new Route({
        method  : &apos;get&apos;,
        path    : &apos;*all&apos;,
        handler : sinon.spy()
      });

      const req = new Request({
        method  : &apos;get&apos;,
        path    : &apos;/a/b/c&apos;,
        headers : {}
      });

      expect(route.isMatch(req)).to.be.true;
    });

    it(&apos;should return false if a the method is wrong&apos;, () =&gt; {
      const req = new Request({
        method  : &apos;put&apos;,
        path    : &apos;/&apos;,
        headers : {}
      });

      expect(route.isMatch(req)).to.be.false;
    });

    it(&apos;should return false if a the path is wrong&apos;, () =&gt; {
      const req = new Request({
        method  : &apos;get&apos;,
        path    : &apos;/a/b&apos;,
        headers : {}
      });

      expect(route.isMatch(req)).to.be.false;
    });
  });

  describe(&apos;#execute&apos;, () =&gt; {
    let request;
    let response;

    it(&apos;should throw if options is not defined&apos;, () =&gt; {
      expect(() =&gt; {
        route.execute();
      }).to.throw(&apos;options must be an object.&apos;);
    });

    it(&apos;should throw if options is not an object&apos;, () =&gt; {
      expect(() =&gt; {
        route.execute(7);
      }).to.throw(&apos;options must be an object.&apos;);
    });

    it(&apos;should throw if the input is not a request object&apos;, () =&gt; {
      expect(() =&gt; {
        route.execute({});
      }).to.throw(&apos;request must be a SuperRouter Request instance.&apos;);
    });

    it(&apos;should throw if the second input is not a response object&apos;, () =&gt; {
      request = new Request({
        method  : &apos;get&apos;,
        path    : &apos;/a/b&apos;,
        headers : {}
      });

      expect(() =&gt; {
        route.execute({ request });
      }).to.throw(&apos;response must be a SuperRouter Response instance.&apos;);
    });

    describe(&apos;on non-match&apos;, () =&gt; {
      beforeEach(() =&gt; {
        request  = new Request({
          method  : &apos;get&apos;,
          path    : &apos;/a/b&apos;,
          headers : {}
        });
        response = new Response();
      });

      it(&apos;should return a promise&apos;, () =&gt; {
        expect(Q.isPromise(route.execute({ request, response }))).to.be.true;
      });

      it(&apos;should resolve the promise without executing the handler&apos;, () =&gt; {
        return route.execute({ request, response }).then(() =&gt; {
          expect(handler).to.not.have.been.called;
        });
      });

      it(&apos;should pass properties on options to handler&apos;, () =&gt; {
        const opts = {
          request  : new Request({
            method  : &apos;get&apos;,
            path    : &apos;/&apos;,
            headers : {}
          }),
          response : new Response(),
          a        : 1,
          b        : &apos;thing&apos;
        };

        return route.execute(opts).then(() =&gt; {
          expect(handler).to.have.been.calledWith(opts);
        });
      });

    });

    describe(&apos;on match&apos;, () =&gt; {
      beforeEach(() =&gt; {
        request  = new Request({
          method  : &apos;get&apos;,
          path    : &apos;/&apos;,
          headers : {}
        });
        response = new Response();
      });

      it(&apos;should return a promise&apos;, () =&gt; {
        expect(Q.isPromise(route.execute({ request, response }))).to.be.true;
      });

      it(&apos;should resolve the promise, executing the handler if the request is a match&apos;, () =&gt; {
        return route.execute({ request, response }).then(() =&gt; {
          expect(handler).to.have.been.calledOnce;
        });
      });

      it(&apos;should pass the request and response to the handler&apos;, () =&gt; {
        return route.execute({ request, response }).then(() =&gt; {
          expect(handler).to.have.been.calledWith({ request, response });
        });
      });

      it(&apos;should catch any thrown errors and reject the promise with them&apos;, () =&gt; {
        const err = new Error(&apos;A TERRIBLE TRAGEDY&apos;);
        handler.throws(err);

        return route.execute({ request, response }).catch((thrownErr) =&gt; {
          expect(thrownErr).to.equal(err);
        });
      });

      it(&apos;should resolve with the return value if the handler does not return a promise&apos;, () =&gt; {
        handler.returns(&apos;resolveVal&apos;);

        return route.execute({ request, response }).then((res) =&gt; {
          expect(res).to.equal(&apos;resolveVal&apos;);
        });
      });

      it(&apos;should resolve if the handler resolves&apos;, () =&gt; {
        handler.returnsPromise();
        handler.resolves(&apos;resolveVal&apos;);

        return route.execute({ request, response }).then((res) =&gt; {
          expect(res).to.equal(&apos;resolveVal&apos;);
        });
      });

      it(&apos;should reject if the handler rejects&apos;, () =&gt; {
        handler.returnsPromise();
        const err = new Error(&apos;A TERRIBLE TRAGEDY&apos;);
        handler.rejects(err);

        return route.execute({ request, response }).catch((thrownErr) =&gt; {
          expect(thrownErr).to.equal(err);
        });
      });

      it(&apos;should propagate mutations on the request and response that occur within the handler&apos;, () =&gt; {
        route = new Route({
          path    : &apos;/&apos;,
          method  : &apos;get&apos;,
          handler : (opts) =&gt; {
            const req = opts.request;
            const res = opts.response;

            req.a = 1;
            res.b = 2;
          }
        });

        return route.execute({ request, response }).then(() =&gt; {
          expect(request.a).to.equal(1);
          expect(response.b).to.equal(2);
        });
      });

      describe(&apos;routeParams&apos;, () =&gt; {
        beforeEach(() =&gt; {
          route = new Route({
            path    : &apos;/user(/:type)/:id(/*rest)&apos;,
            method  : &apos;get&apos;,
            handler : sinon.spy()
          });
        });

        it(&apos;should create a routeParams property on the request&apos;, () =&gt; {
          request = new Request({
            path    : &apos;/&apos;,
            method  : &apos;get&apos;,
            headers : {}
          });
          route.execute({ request, response });
          expect(request.routeParams).to.exist;
          expect(request.routeParams).to.eql({});
        });

        it(&apos;should overwrite an existing routeParams property&apos;, () =&gt; {
          request             = new Request({
            path    : &apos;/&apos;,
            method  : &apos;get&apos;,
            headers : {}
          });
          request.routeParams = { a : 1 };
          route.execute({ request, response });
          expect(request.routeParams).to.exist;
          expect(request.routeParams).to.eql({});
        });

        it(&apos;should represent each match from the route path on the routeParams property&apos;, () =&gt; {
          request = new Request({
            path    : &apos;/user/red/17/a/b/c&apos;,
            method  : &apos;get&apos;,
            headers : {}
          });
          route.execute({ request, response });
          expect(request.routeParams).to.exist;
          expect(request.routeParams).to.eql({
            type : &apos;red&apos;,
            id   : &apos;17&apos;,
            rest : &apos;a/b/c&apos;
          });
        });
      });
    });
  });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
