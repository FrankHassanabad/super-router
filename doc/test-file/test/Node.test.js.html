<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">test/Node.test.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/autoric/super-router" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Response.js~Response.html">Response</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Router.js~Router.html">Router</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">test/Node.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;
const chai              = require(&apos;chai&apos;);
const sinon             = require(&apos;sinon&apos;);
const sinonChai         = require(&apos;sinon-chai&apos;);
const sinonStubPromises = require(&apos;sinon-promises&apos;);
const chaiAsPromised    = require(&apos;chai-as-promised&apos;);
const _                 = require(&apos;lodash&apos;);

sinonStubPromises(sinon);
chai.use(chaiAsPromised);
chai.use(sinonChai);

const expect = chai.expect;

const Node    = require(&apos;../lib/Node&apos;);
const Route   = require(&apos;../lib/Route&apos;);
const Request = require(&apos;../lib/Request&apos;);
let sandbox;

describe(&apos;Node &apos;, () =&gt; {
  const OPTIONS_ERROR    = &apos;options must be an object.&apos;;
  const PATH_ERROR       = &apos;path must be a string.&apos;;
  const PATH_START_ERROR = &apos;path must start with a / character.&apos;;

  beforeEach(() =&gt; {
    sandbox = sinon.sandbox.create();
  });

  afterEach(() =&gt; {
    sandbox.restore();
  });

  describe(&apos;constructor&apos;, () =&gt; {
    it(&apos;should throw if options is undefined&apos;, () =&gt; {
      expect(() =&gt; {
        new Node();
      }).to.throw(OPTIONS_ERROR);
    });

    it(&apos;should throw if options is not an object&apos;, () =&gt; {
      expect(() =&gt; {
        new Node(&apos;asdf&apos;);
      }).to.throw(OPTIONS_ERROR);
    });

    it(&apos;should throw if options.path is undefined&apos;, () =&gt; {
      expect(() =&gt; {
        new Node({});
      }).to.throw(PATH_ERROR);
    });

    it(&apos;should throw if options.path is not a string&apos;, () =&gt; {
      expect(() =&gt; {
        new Node({ path : 7 });
      }).to.throw(PATH_ERROR);
    });

    it(&apos;should throw if path does not start with a / character&apos;, () =&gt; {
      expect(() =&gt; {
        new Node({ path : &apos;asdf&apos; });
      }).to.throw(PATH_START_ERROR);
    });

    it(&apos;should set the path property from the constructor&apos;, () =&gt; {
      const node = new Node({ path : &apos;/user&apos; });
      expect(node.path).to.equal(&apos;/user&apos;);
    });

    it(&apos;should throw on assignment to path&apos;, () =&gt; {
      const node = new Node({ path : &apos;/user&apos; });
      expect(() =&gt; {
        node.path = &apos;/asdfa&apos;;
      }).to.throw(&apos;Cannot set property&apos;);
    });

    it(&apos;should add an options route&apos;, () =&gt; {
      const node = new Node({ path : &apos;/user&apos; });
      expect(node.getRoutes()).to.have.length(1);
      const optsRoute = node.getRoutes()[0];
      expect(optsRoute.methods).to.eql([&apos;OPTIONS&apos;]);
    });
  });

  describe(&apos;methods&apos;, () =&gt; {
    let node;
    let route;

    beforeEach(() =&gt; {
      route = {
        path    : &apos;/user&apos;,
        methods : &apos;get&apos;,
        handler : () =&gt; {

        }
      };
      node  = new Node({ path : &apos;/user&apos; });
    });

    describe(&apos;#_optionsHandler&apos;, () =&gt; {

    });

    describe(&apos;#addRoute&apos;, () =&gt; {
      it(&apos;should throw if the route path does not match the node path pattern&apos;, () =&gt; {

      });

      it(&apos;should throw if the path of the route does not match the path of the node&apos;, () =&gt; {
        route.path = &apos;/junk&apos;;
        expect(() =&gt; {
          node.addRoute(route);
        }).to.throw(&apos;route path must match node path.&apos;);
      });

      it(&apos;should throw if the method is already defined for this node&apos;, () =&gt; {
        node.addRoute(route);
        expect(() =&gt; {
          node.addRoute(route);
        }).to.throw(&apos;duplicate method &quot;GET&quot; added for path &quot;/user&quot;&apos;);
      });

      it(&apos;should throw if the method is already defined using an array of methods for this node&apos;, () =&gt; {
        route.methods = [&apos;get&apos;, &apos;post&apos;];
        node.addRoute(route);
        expect(() =&gt; {
          route.methods = &apos;get&apos;;
          node.addRoute(route);
        }).to.throw(&apos;duplicate method &quot;GET&quot; added for path &quot;/user&quot;&apos;);
      });

      it(&apos;should throw if one of the methods in array is already defined for this node&apos;, () =&gt; {
        node.addRoute(route);
        expect(() =&gt; {
          route.methods = [&apos;get&apos;, &apos;post&apos;];
          node.addRoute(route);
        }).to.throw(&apos;duplicate method &quot;GET&quot; added for path &quot;/user&quot;&apos;);
      });

      it(&apos;should throw if the route method is ALL&apos;, () =&gt; {
        route.methods = &apos;*&apos;;

        expect(() =&gt; {
          node.addRoute(route);
        }).to.throw(&apos;cannot register route with method ALL on node.&apos;);
      });
    });

    describe(&apos;#addChild&apos;, () =&gt; {

      it(&apos;should be able to add children and be returned with getChildren&apos;, () =&gt; {
        const child1 = new Node({ path : &apos;/child1&apos; });
        const child2 = new Node({ path : &apos;/child2&apos; });
        const child3 = new Node({ path : &apos;/child3&apos; });
        node.addChild(child1);
        node.addChild(child2);
        node.addChild(child3);
        expect(node.getChildren()).to.eql([child1, child2, child3]);
      });

      it(&apos;should throw an error if a child with a duplicate path is added&apos;, () =&gt; {
        const child = new Node({ path : &apos;/child&apos; });
        node.addChild(child);
        expect(() =&gt; {
          node.addChild(child);
        }).to.throw(`Cannot add duplicate child on path ${child.path}`);
      });

    });

    describe(&apos;tree walkers&apos;, () =&gt; {
      let root, a, az, abc, abd;
      beforeEach(() =&gt; {
        root = new Node({ path : &apos;/&apos; });
        a    = new Node({ path : &apos;/a&apos; });
        abc  = new Node({ path : &apos;/a/b/c&apos; });
        abd  = new Node({ path : &apos;/a/b/d&apos; });
        az   = new Node({ path : &apos;/a/z&apos; });

        root.addChild(a);
        a.addChild(az);
        a.addChild(abc);
        a.addChild(abd);
      });

      describe(&apos;#insert&apos;, () =&gt; {

        it(&apos;should throw an error if the route path is not contained in the nodes path&apos;, () =&gt; {
          const route = new Route({
            path    : &apos;/&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });

          expect(() =&gt; {
            abc.insert(route);
          }).to.throw(&apos;Cannot insert&apos;);
        });

        it(&apos;should throw an error if the node path does not start the route path&apos;, () =&gt; {
          const route = new Route({
            path    : &apos;/b/c&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });

          expect(() =&gt; {
            abd.insert(route);
          }).to.throw(&apos;Cannot insert&apos;);
        });

        it(&apos;should add the route to the node if the paths match&apos;, () =&gt; {
          sandbox.spy(root, &apos;addRoute&apos;);
          const route = new Route({
            path    : &apos;/&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          root.insert(route);

          expect(root.addRoute).to.have.been.calledOnce;
          expect(root.addRoute).to.have.been.calledWith(route);
        });

        it(&apos;should insert on a child node, if possible&apos;, () =&gt; {
          const route = new Route({
            path    : &apos;/a/b/c/e&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          sinon.spy(a, &apos;insert&apos;);
          sinon.spy(abc, &apos;insert&apos;);
          sinon.spy(abd, &apos;insert&apos;);

          root.insert(route);
          expect(a.insert).to.have.been.calledWith(route);
          expect(abc.insert).to.have.been.calledWith(route);
          expect(abd.insert).to.not.have.been.calledWith(route);
        });

        it(&apos;should add a new child otherwise&apos;, () =&gt; {
          const route   = new Route({
            path    : &apos;/a/b&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          sinon.spy(a, &apos;insert&apos;);
          sinon.spy(a, &apos;addChild&apos;);

          root.insert(route);
          expect(a.insert).to.have.been.calledWith(route);
          expect(a.addChild).to.have.been.calledOnce;
          const newNode = a.addChild.firstCall.args[0];
          expect(newNode.path).to.equal(&apos;/a/b&apos;);
          expect(newNode.getRoutes()).to.contain(route);
        });

        it(&apos;should reassign children as needed&apos;, () =&gt; {
          const route  = new Route({
            path    : &apos;/a/b&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });

          root.insert(route);
          expect(root.getChildren()).to.eql([a]);
          const aChildren = a.getChildren();
          expect(aChildren).to.have.length(2);
          expect(aChildren).to.contain(az);
          const ab = _.find(aChildren, (child) =&gt; {
            return child !== az;
          });
          expect(ab.getChildren()).to.eql([abc, abd]);
        });

        it(&apos;should insert correctly on route patterns, regardless of param names&apos;, () =&gt; {
          const node = new Node({ path : &apos;/users/:id&apos; });
          const route1 = new Route({
            path    : &apos;/users/:id&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          const route2 = new Route({
            path    : &apos;/users/:userId&apos;,
            methods : &apos;put&apos;,
            handler : sinon.spy()
          });
          node.insert(route1);
          node.insert(route2);

          expect(node.getRoutes()).to.contain(route1);
          expect(node.getRoutes()).to.contain(route2);
        });
      });


      describe(&apos;#find&apos;, () =&gt; {
        let rootGet, aGet;
        beforeEach(() =&gt; {
          rootGet = new Route({
            path    : &apos;/&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          root.addRoute(rootGet);

          aGet = new Route({
            path    : &apos;/a&apos;,
            methods : &apos;get&apos;,
            handler : sinon.spy()
          });
          a.addRoute(aGet);
        });

        it(&apos;should return a match from its routes, if it exists&apos;, () =&gt; {
          const request = new Request({
            path    : &apos;/&apos;,
            method  : &apos;get&apos;,
            headers : {}
          });

          expect(root.find(request)).to.equal(rootGet);
        });

        it(&apos;should return undefined if request matches the path, but the route doesnt exist&apos;, () =&gt; {
          const request = new Request({
            path    : &apos;/&apos;,
            method  : &apos;post&apos;,
            headers : {}
          });

          expect(() =&gt; {
            root.find(request);
          }).to.throw(&apos;Invalid method&apos;);
        });

        it(&apos;should return a match from its children&apos;, () =&gt; {
          const request = new Request({
            path    : &apos;/a&apos;,
            method  : &apos;get&apos;,
            headers : {}
          });

          expect(root.find(request)).to.equal(aGet);
        });
      });

      describe(&apos;#toObject&apos;, () =&gt; {

      });
    });
  });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
