<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/Route.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/autoric/super-router" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Node.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Response.js~Response.html">Response</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Router.js~Router.html">Router</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/Route.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;
const _           = require(&apos;lodash&apos;);
const Q           = require(&apos;q&apos;);
const utils       = require(&apos;./utils&apos;);
const METHODS     = require(&apos;./METHODS&apos;);
const Request     = require(&apos;./Request&apos;);
const Response    = require(&apos;./Response&apos;);
const RouteParser = require(&apos;route-parser&apos;);

/**
 * Route class.
 * A route is defined as a path pattern, method, and handler. Testing requests against routes and executing matching
 * handlers is the core of request processing.
 */
class Route {

  /**
   * Instantiates a new Route.
   *
   * @param {Object} options - The options object
   * @param {Function} options.handler - The handler function to be executed if the route is matched.
   * @param {Function} options.errorHandler - The handler function to be executed if the route throws an error.
   * @param {String} [path=&apos;*all&apos;] - The path pattern that the route should be executed against. If not provided,
   *  matches all paths.
   * @param {String | Array} [method=&apos;*&apos;] - The method(s) that the route should be executed against. If not provided, mathes
   *  all methods.
   * @returns {Route} - The new route instance.
   */
  constructor(options) {
    if (!_.isObject(options)) {
      throw new TypeError(&apos;options must be an object.&apos;);
    }
    if (!_.isFunction(options.handler)) {
      throw new TypeError(&apos;handler must be a function.&apos;);
    }
    if (!_.isUndefined(options.errorHandler) &amp;&amp; !_.isFunction(options.errorHandler)) {
      throw new TypeError(&apos;errorHandler must be a function.&apos;);
    }
    if (options.path &amp;&amp; !_.isString(options.path)) {
      throw new TypeError(&apos;path must be a string.&apos;);
    }
    if (options.methods &amp;&amp; !utils.isValidMethodArray(options.methods)) {
      throw new TypeError(&apos;method must be a valid method string.&apos;);
    }

    _.extend(this, options);

    this._path    = utils.normalizePath(options.path || &apos;*all&apos;);
    this._methods = this._convertAndNormalizeMethods(options.methods || METHODS.ALL);
    this._handler = options.handler;
    this._errorHandler = options.errorHandler;
    this._parsed  = new RouteParser(this._path);
  }

  /**
   * Returns the route path.
   *
   * @returns {String} - The route path.
   */
  get path() {
    return this._path;
  }

  /**
   * Returns the route method.
   *
   * @returns {String} - The route method.
   */
  get methods() {
    return this._methods;
  }

  /**
   * Returns the route handler.
   *
   * @returns {Function} - The route handler.
   */
  get handler() {
    return this._handler;
  }

  /**
   * Returns the error handler.
   *
   * @returns {Function} - The error handler.
   */
  get errorHandler() {
    return this._errorHandler;
  }

  /**
   * Tests if the given method matches this route
   *
   * @param {String} method - The input method
   * @returns {boolean} - If the method matches this route
   * @private
   */
  _isMethodMatch(method) {
    return (_.contains(this.methods, METHODS.ALL)) || (_.difference(this._convertAndNormalizeMethods(method), this.methods).length === 0);
  }

  /**
   * Converts and normalize method(s) to an array
   *
   * @param {Array | String} methodArray - The input method
   * @returns {Array} - Array of methods
   * @private
   */
  _convertAndNormalizeMethods(methodArray) {
    return this._normalizeAllMethods(this._convertMethodsToArray(methodArray));
  }

  /**
   * Converts method(s) to an array
   *
   * @param {Array | String} methodArray - The input method
   * @returns {Array} - Array of methods
   * @private
   */
  _convertMethodsToArray(methodArray) {
    if (!_.isArray(methodArray)) {
      methodArray = [methodArray];
    }
    return methodArray;
  }

  /**
   * Normalizes all methods in an array
   *
   * @param {Array} methodArray - The input method
   * @returns {Array} - Array of normalized methods
   * @private
   */
  _normalizeAllMethods(methodArray) {
    return _.map(methodArray, function (method) {
      return utils.normalizeMethod(method);
    });
  }

  /**
   * Parses the given path string against this route&apos;s path pattern. If the input path is a match, returns
   * an object whose key value pairs are the matched route params and their values. If the path is not a match,
   * returns false.
   *
   * @param {String} path - The input path
   * @returns {Boolean|Object} - False if the path is not a match, an object if it is.
   * @private
   */
  _parsePath(path) {
    return this._parsed.match(path);
  }

  /**
   * Tests whether a given request object is a match against this route, satisfying the path &amp; method requirements.
   *
   * @param {Request} request - The input requiest
   * @returns {Boolean} - Whether the request matches this route.
   */
  isMatch(request) {
    if (!(request instanceof Request)) {
      throw new Error(&apos;First argument: request must be a SuperRouter Request instance.&apos;);
    }
    return this._isMethodMatch(request.method) &amp;&amp; _.isObject(this._parsePath(request.path));
  }

  /**
   * Executes this route against a provided request / response. Returns a promise that will resolve or reject when
   * execution is complete.
   *  - If the request is not a match, returns an empty promise.
   *  - If the request is a match, returns a promise for the return value of the route handler
   *
   * @param {Object} options - The options object
   * @param {Request} options.request - The request the route will be tested &amp; executed against
   * @param {Response} options.response - The response the route handler will be invoked with
   * @returns {Promise} - A promise that will complete when execution is complete.
   */
  execute(options) {
    if (!_.isObject(options)) {
      throw new TypeError(&apos;options must be an object.&apos;);
    }

    const request  = options.request;
    const response = options.response;

    if (!(request instanceof Request)) {
      throw new Error(&apos;request must be a SuperRouter Request instance.&apos;);
    }
    if (!(response instanceof Response)) {
      throw new Error(&apos;response must be a SuperRouter Response instance.&apos;);
    }

    request.routeParams = {};
    if (!this.isMatch(request)) {
      return Q();
    }
    try {
      request.routeParams = this._parsePath(request.path);

      return Q().then(() =&gt; {
        return this.handler(options);
      }).catch((error) =&gt; {
        if (this.errorHandler) {
          return this.errorHandler({ request, response, error });
        }
        else {
          throw error;
        }
      });
    }
    catch (err) {
      return Q.reject(err);
    }
  }

}

module.exports = Route;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
